<!--
/*
 * Copyright 2014, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-->
<!DOCTYPE html>
<html>
<head>
<title>PowPow</title>
<style>
html, body {
  width: 100%;
  height: 100%;
  border: 0px;
  padding: 0px;
  margin: 0px;
  background-color: purple; //black;
  font-family: sans-serif;
  color: white;
  font-size: 20px;
}
#url {
  height: 5%;
  background-color: #008;
  text-align: center;
}
#outer {
  width: 100%;
  height: 100%;
}
#main {
  float: left;
  width: 85%;
  height: 100%;
}
#canvas {
  width: 100%;
  height: 95%;
  background-color: black;
  gbackground-image: url(assets/background.jpg);
  gbackground-size: 100%;
}
#status {
  float: right;
  width: 15%;
  background-color: red;
  height: 100%;
}
#highscore, #queue {
  white-space: nowrap;
  overflow: hidden;
  height: 100%;
  background-color: #008;
}
#highscores-outer {
  width: 100%;
  height: 50%;
  background-color: blue;
}
#queue-outer {
  width: 100%;
  height: 50%;
  background-color: blue;
}
#queue-canvas {
  width: 100%;
  height: 100%;
}
#disconnected {
  position: absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  display: none;
  background-color: red;
  text-align: center;
  z-index: 1000
}
</style>
<!--
<script data-main="scripts/main.js" src="scripts/require.js"></script>
-->
<script type="text/javascript" src="/socket.io/socket.io.js"></script>
<script type="text/javascript" src="../scripts/tdl/base.js"></script>
<script type="text/javascript" src="../../scripts/gameserver.js"></script>
<script type="text/javascript" src="scripts/canvasrenderer.js"></script>
<script type="text/javascript" src="scripts/webglrenderer.js"></script>
<script type="text/javascript" src="scripts/2d.js"></script>
<script type="text/javascript" src="scripts/player.js"></script>
<script type="text/javascript" src="scripts/metaplayer.js"></script>
<script type="text/javascript" src="scripts/shot.js"></script>
<script type="text/javascript" src="scripts/plistmanager.js"></script>
<script type="text/javascript" src="scripts/queuemanager.js"></script>
<script type="text/javascript" src="scripts/scoremanager.js"></script>
<script type="text/javascript" src="scripts/entitysystem.js"></script>
<script type="text/javascript" src="scripts/ships.js"></script>
<script type="text/javascript" src="../scripts/audio.js"></script>
<script>
tdl.require('tdl.buffers');
tdl.require('tdl.fast');
tdl.require('tdl.framebuffers');
tdl.require('tdl.log');
tdl.require('tdl.math');
tdl.require('tdl.models');
tdl.require('tdl.particles');
tdl.require('tdl.primitives');
tdl.require('tdl.programs');
tdl.require('tdl.textures');
tdl.require('tdl.webgl');

var g_activePlayers = [];  // players currently playing (not in queue)
var g_metaQueuePlayer;
var g_players = [];  // all players
var g_shotsById = {};

var main = (function(){
var g_canvas;
var g_debug = false;
var g_logGLCalls = false;
var g_updateStatus = false;
var g_services = {};

// You can set these from the URL with
// http://path/gameview.html?settings={name:value,name:value}
var globals = {
  maxActivePlayers: 6,
  playerVelocity: 200,
  playerTurnVelocity: Math.PI * 0.5,
  invincibilityDuration: 3,
  maxShots: 2,
  shotDuration: 3,
  shotVelocity: 300,
  port: 8080,
  haveServer: true,
  width: 100,
  height: 100,
};

// g_debug = true;
// g_logGLCalls = true;

function $(id) {
  return document.getElementById(id);
}

function logTo(id, str) {
  var c = $(id);
  var d = document.createElement("div");
  d.appendChild(document.createTextNode(str));
  c.appendChild(d);
}

function log() {
  var s = ""
  for (var ii = 0; ii < arguments.length; ++ii) {
    s += arguments[ii].toString();
  }
  logTo("console", s);
}

function ValidateNoneOfTheArgsAreUndefined(functionName, args) {
  for (var ii = 0; ii < args.length; ++ii) {
    if (args[ii] === undefined) {
      tdl.error("undefined passed to gl." + functionName + "(" +
                tdl.webgl.glFunctionArgsToString(functionName, args) + ")");
    }
  }
}

function Log(msg) {
  if (g_logGLCalls) {
    tdl.log(msg);
  }
}

function LogGLCall(functionName, args) {
  if (g_logGLCalls) {
    ValidateNoneOfTheArgsAreUndefined(functionName, args)
    tdl.log("gl." + functionName + "(" +
                tdl.webgl.glFunctionArgsToString(functionName, args) + ")");
  }
}

function startPlayer(netPlayer, name) {
  var x = Math.random() * g_canvas.width;
  var y = Math.random() * g_canvas.height;
  var direction = Math.random() * Math.PI * 2;
  var player = new Player(g_services, x, y, direction, name, netPlayer);
  if (g_players.length == 0) {
	g_services.audioManager.playSound('play');
  }
  g_players.push(player);
  return player;
}

function removePlayer(netPlayer) {
  for (var ii = 0; ii < g_players.length; ++ii) {
	var player = g_players[ii];
	if (player.netPlayer === netPlayer) {
	  g_players.splice(ii, 1);
	  player.removeFromGame();
	  if (g_players.length == 0) {
		g_services.audioManager.playSound('gameover');
	  }
	  return;
	}
  }
}

function showConnected() {
  $('outer').style.display = "block";
  $('disconnected').style.display = "none";
}

function showDisconnected() {
  $('outer').style.display = "none";
  $('disconnected').style.display = "block";
}

function startMetaQueuePlayer() {
  if (g_metaQueuePlayer)
    return g_metaQueuePlayer;
  var x = g_canvas.width / 2;
  var y = g_canvas.height / 2;
  var direction = Math.random() * Math.PI * 2;

  g_metaQueuePlayer = new MetaQueuePlayer(g_services, x, y, direction);
  return g_metaQueuePlayer;
}

function main() {
  tdl.misc.applyUrlSettings(globals);

  g_canvas = $("canvas");
  if (globals.msg) {
    $("url").innerHTML = globals.msg;
  } else if (globals.haveServer) {
    $("url").innerHTML = "To Play Go To " +
        window.location.href.replace(/\/[^/]*$/, '');
  } else {
    $("url").innerHTML = "!!DEBUG MODE!! -- Must run from server to play";
  }

  var gl = tdl.webgl.setupWebGL(g_canvas, undefined, function() {});
  if (g_debug) {
    gl = tdl.webgl.makeDebugContext(gl, undefined, LogGLCall);
  }
  var renderer = gl ? new WebGLRenderer(g_canvas, gl) : new CanvasRenderer(g_canvas);

  g_services.globals = globals;
  g_services.renderer = renderer;

  var server = new GameServer();
  g_services.server = server;
  server.addEventListener('connect', showConnected);
  server.addEventListener('disconnect', showDisconnected);
  server.addEventListener('playerconnect', startPlayer);
  server.addEventListener('playerdisconnect', removePlayer);
  server.init();

  var audioManager = new AudioManager();
  g_services.audioManager = audioManager;
  audioManager.init({
    fire: {
      filename: "assets/fire.ogg",
      samples: 8,
    },
    explosion: {
      filename: "assets/explosion.ogg",
      samples: 6,
    },
    hitshield: {
      filename: "assets/hitshield.ogg",
      samples: 6,
    },
    launch: {
      filename: "assets/launch.ogg",
      samples: 2,
    },
    gameover: {
      filename: "assets/gameover.ogg",
      samples: 1,
    },
    play: {
      filename: "assets/play.ogg",
      samples: 1,
    },
  });
  var entitySys = new EntitySystem();
  g_services.entitySystem = entitySys;
  var scoreMgr = new ScoreManager(g_services, $("highscore"));
  g_services.scoreManager = scoreMgr;
  var queueMgr = new QueueManager(g_services, $("queue"));
  g_services.queueManager = queueMgr;

  startMetaQueuePlayer();

  // Add a 2 players if there is no communication
  if (!globals.haveServer) {
    startLocalPlayers();
  }

  var then = (new Date()).getTime() * 0.001;
  render();

  function render() {
    var now = (new Date()).getTime() * 0.001;
    var elapsedTime = Math.min(now - then, 1 / 10);	// don't advance more then a 1/10 of a second;
    then = now;

    renderer.resize();
	globals.width = g_canvas.width;
	globals.height = g_canvas.height;

    queueMgr.process(elapsedTime);
    entitySys.processEntities(elapsedTime);
    scoreMgr.update();

    renderer.begin(elapsedTime);

    g_metaQueuePlayer.draw(renderer);
    for (var ii = 0; ii < g_activePlayers.length; ++ii) {
      g_activePlayers[ii].draw(renderer);
    }
    for (var shotId in g_shotsById) {
      g_shotsById[shotId].draw(renderer);
    }

    //g_queueMgr.draw();
    scoreMgr.draw(renderer);
    renderer.end(elapsedTime);

    if (g_updateStatus) {
      g_updateStatus = false;
      queueMgr.draw();
      scoreMgr.drawScores();
    }

    // turn off logging after 1 frame.
    g_logGLCalls = false;

    requestAnimationFrame(render, g_canvas);
  }
}

function startLocalPlayers() {
  globals.maxActivePlayers = 2;
  var player1 = startPlayer(new LocalNetPlayer(), "Player1");
  var player2 = startPlayer(new LocalNetPlayer(), "Player2");
  var player3 = startPlayer(new LocalNetPlayer(), "Player3"); // in queue
  var player4 = startPlayer(new LocalNetPlayer(), "Player4"); // in queue
  var g_left = false;
  var g_right = false;
  var g_fire = false;
  var g_keyState = { };
  var g_oldKeyState = { };

  function handleKeyDown(keyCode, state) {
    switch(keyCode) {
	case 37: // left
      if (!g_left) {
        g_left = true;
		player1.handleTurnMsg({turn: -1});
      }
      break;
    case 39: // right
      if (!g_right) {
        g_right = true;
		player1.handleTurnMsg({turn: 1});
      }
      break;
    case 90: // z
      if (!g_fire) {
        g_fire = true;
		player1.handleFireMsg({fire:1});
      }
      break;
    }
  }

  function handleKeyUp(keyCode, state) {
    switch(keyCode) {
    case 37: // left
      g_left = false;
	  player1.handleTurnMsg({turn: (g_right) ? 1 : 0});
      break;
    case 39: // right
      g_right = false;
	  player1.handleTurnMsg({turn: (g_left) ? -1 : 0});
      break;
    case 90: // z
      g_fire = false;
      player1.handleFireMsg({fire: 0});
      break;
    }
  }

  function updateKey(keyCode, state) {
    g_keyState[keyCode] = state;
    if (g_oldKeyState != g_keyState) {
      g_oldKeyState = state;
      if (state) {
        handleKeyDown(keyCode);
      } else {
        handleKeyUp(keyCode);
      }
    }
  }

  function keyUp(event) {
    updateKey(event.keyCode, false);
  }

  function keyDown(event) {
    updateKey(event.keyCode, true);
  }

  window.addEventListener("keyup", keyUp, false);
  window.addEventListener("keydown", keyDown, false);
}
return main;
}());

window.onload = main;

</script>
<script id="screenVertexShader" type="whatever">
uniform mat3 matrix;
uniform vec2 screenDimensions;
attribute vec2 position;

void main() {
  vec3 pos = vec3(-1, -1, 0) + matrix * vec3(position, 1) * vec3(screenDimensions, 0);
  gl_Position = vec4(pos.x, -pos.y, 0, 1);
}
</script>
<script id="screenFragmentShader" type="whatever">
#ifdef GL_ES
precision highp float;
#endif
uniform vec4 color;
void main() {
  gl_FragColor = color;
}
</script>
<script id="twoToneVertexShader" type="whatever">
uniform mat3 matrix;
uniform vec2 screenDimensions;
attribute vec2 position;
attribute float colorMult;
varying float v_colorMult;

void main() {
  vec3 pos = vec3(-1, -1, 0) + matrix * vec3(position, 1) * vec3(screenDimensions, 0);
  gl_Position = vec4(pos.x, -pos.y, 0, 1);
  v_colorMult = colorMult;
}
</script>
<script id="twoToneFragmentShader" type="whatever">
#ifdef GL_ES
precision highp float;
#endif
uniform vec4 color;
varying float v_colorMult;
void main() {
  gl_FragColor = color * vec4(v_colorMult, v_colorMult, v_colorMult, 1);
}
</script>
<script id="persistVertexShader" type="whatever">
attribute vec2 position;
attribute vec2 texCoord;
varying vec2 v_texCoord;
void main() {
  gl_Position = vec4(position, 0, 1);
  v_texCoord = texCoord;
}
</script>
<script id="persistFragmentShader" type="whatever">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D newRender;
uniform sampler2D oldRender;
uniform float persistence;
varying vec2 v_texCoord;
void main() {
  vec4 newColor = texture2D(newRender, v_texCoord);
  vec4 oldColor = texture2D(oldRender, v_texCoord);
  float alpha = newColor.a;
  float mixAmount = length(newColor.xyz) * alpha;
  mixAmount = mix(persistence, 1.0, alpha);
  gl_FragColor =
    vec4(
      mix(oldColor.g, newColor.r, mixAmount),
      mix(oldColor.b, newColor.g, mixAmount),
      mix(oldColor.r, newColor.b, mixAmount),
      1);
}
</script>
<script id="mainVertexShader" type="whatever">
attribute vec2 position;
attribute vec2 texCoord;
varying vec2 v_texCoord;
void main() {
  gl_Position = vec4(position, 0, 1);
  v_texCoord = texCoord;
}
</script>
<script id="mainFragmentShader" type="whatever">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D texture;
varying vec2 v_texCoord;
void main() {
  vec4 color = texture2D(texture, v_texCoord);
  gl_FragColor = color;
}
</script>
</head>
<body>
<div id="outer">
  <div id="main">
    <div id="url">test</div>
    <canvas id="canvas"></canvas>
  </div>
  <div id="status">
    <div id="highscores-outer">
      <div class="headline">High Score</div>
      <div id="highscore"></div>
    </div>
    <div id="queue-outer">
      <div class="headline">Waiting</div>
      <div id="queue"></div>
    </div>
  </div>
</div><div id="disconnected">
  <div class="instruction">Disconnected</div>
  <div id="reload">...lost connection to server (T_T)...</div>
</div></body>
</html>

